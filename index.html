<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGPU Shadertoy</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/mode/simple.min.js"></script>
  <style>
    .cm-s-gruvbox-dark-hard.CodeMirror {
      background-color: #1d2021;
      color: #ebdbb2;
      height: 100%;
      overflow-y: auto;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-gutters {
      background-color: #1d2021;
      border-right: 1px solid #3c3836;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-guttermarker,
    .cm-s-gruvbox-dark-hard .CodeMirror-guttermarker-subtle,
    .cm-s-gruvbox-dark-hard .CodeMirror-linenumber {
      color: #7c6f64;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-cursor {
      border-left: 1px solid #ebdbb2;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-activeline-background {
      background-color: #3c3836;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-selected {
      background-color: #504945;
    }

    .cm-s-gruvbox-dark-hard span.cm-comment {
      color: #928374;
    }

    .cm-s-gruvbox-dark-hard span.cm-keyword {
      color: #fb4934;
    }

    .cm-s-gruvbox-dark-hard span.cm-operator {
      color: #ebdbb2;
    }

    .cm-s-gruvbox-dark-hard span.cm-punctuation {
      color: #a89984;
    }

    .cm-s-gruvbox-dark-hard span.cm-variable {
      color: #83a598;
    }

    .cm-s-gruvbox-dark-hard span.cm-type {
      color: #fabd2f;
    }

    .cm-s-gruvbox-dark-hard span.cm-def {
      color: #8ec07c;
    }

    .cm-s-gruvbox-dark-hard span.cm-attribute {
      color: #fe8019;
    }

    .cm-s-gruvbox-dark-hard span.cm-builtin {
      color: #fe8019;
    }

    .cm-s-gruvbox-dark-hard span.cm-string {
      color: #b8bb26;
    }

    .cm-s-gruvbox-dark-hard span.cm-number {
      color: #d3869b;
    }

    .cm-s-gruvbox-dark-hard span.cm-error {
      color: #ebdbb2;
      background-color: #fb4934;
    }

    .cm-s-gruvbox-dark-hard .CodeMirror-matchingbracket {
      text-decoration: underline;
      color: #ebdbb2 !important;
    }

    /* Ensure CodeMirror scroll container works properly */
    .CodeMirror-scroll {
      height: 100%;
      overflow-y: auto !important;
      overflow-x: auto !important;
    }

    /* Editor container should fill available space */
    #code-editor-container {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    #code-editor-container .CodeMirror {
      flex: 1;
      min-height: 0;
    }
  </style>
</head>

<body class="font-mono bg-gray-900 text-white overflow-hidden">
  <div id="container" class="flex w-screen h-screen flex-row">
    <div id="canvas-container" class="relative flex-1 bg-black h-full">
      <canvas id="canvas" class="block w-full h-full"></canvas>
      <div id="error-message"
        class="absolute bottom-2.5 left-2.5 right-2.5 text-red-500 text-xs bg-black/80 p-1.5 rounded hidden max-h-24 overflow-y-auto z-10">
      </div>
      <div class="absolute top-4 left-4 text-white/50 text-xs pointer-events-none">
        ZQSD to Move • A/E Up/Down • Left Drag to Look • Right Drag to Pan • Scroll to Zoom
      </div>
    </div>
    <div id="editor-container" class="flex flex-col bg-[#1d2021] w-80 h-full border-l border-[#3c3836]">
      <div class="p-3 border-b border-[#3c3836] font-bold text-[#ebdbb2] flex justify-between items-center">
        <span>Scene Editor</span>
        <span id="fps" class="text-xs font-normal text-[#928374]">0 FPS</span>
      </div>
      <div id="panel-content" class="flex-1 overflow-y-auto p-3">
        <!-- Dynamic Content -->
      </div>
    </div>
  </div>
  <script>
    // ... (shaders object) ...

    let fallbackShader = `// Fragment shader - runs once per pixel
@fragment
fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
    // Simple gradient as fallback
    let uv = fragCoord.xy / uniforms.resolution;
    return vec4<f32>(uv, 0.5, 1.0);
}`;

    // CodeMirror.defineSimpleMode("wgsl", {
    //   start: [
    //     { regex: /\b(fn|let|var|const|if|else|for|while|loop|return|break|continue|discard|switch|case|default|struct|type|alias)\b/, token: "keyword" },
    //     { regex: /\b(bool|i32|u32|f32|f16|vec2|vec3|vec4|mat2x2|mat3x3|mat4x4|array|sampler|texture_2d|texture_3d)\b/, token: "type" },
    //     { regex: /\b(vec2|vec3|vec4|mat2x2|mat3x3|mat4x4|array)<[^>]+>/, token: "type" },
    //     { regex: /\b(abs|acos|all|any|asin|atan|atan2|ceil|clamp|cos|cosh|cross|degrees|determinant|distance|dot|exp|exp2|faceforward|floor|fma|fract|frexp|inversesqrt|ldexp|length|log|log2|max|min|mix|modf|normalize|pow|radians|reflect|refract|round|sign|sin|sinh|smoothstep|sqrt|step|tan|tanh|transpose|trunc)\b/, token: "builtin" },
    //     { regex: /@(vertex|fragment|compute|builtin|location|binding|group|stage|workgroup_size|interpolate|invariant)/, token: "attribute" },
    //     { regex: /\b\d+\.?\d*[fu]?\b|0x[0-9a-fA-F]+[ul]?/, token: "number" },
    //     { regex: /\/\/.*/, token: "comment" },
    //     { regex: /\/\*/, token: "comment", next: "comment" },
    //     { regex: /[+\-*/%=<>!&|^~?:]/, token: "operator" },
    //     { regex: /[{}()\[\];,\.]/, token: "punctuation" },
    //   ],
    //   comment: [
    //     { regex: /.*?\*\//, token: "comment", next: "start" },
    //     { regex: /.*/, token: "comment" },
    //   ],
    // }); // prettier-ignore

    // const editor = CodeMirror.fromTextArea(
    //   document.getElementById("code-editor"),
    //   {
    //     mode: "wgsl",
    //     theme: "gruvbox-dark-hard",
    //     lineNumbers: true,
    //     lineWrapping: true,
    //     value: fallbackShader,
    //     tabSize: 2,
    //     indentUnit: 2,
    //     viewportMargin: Infinity,
    //     scrollbarStyle: "native",
    //   },
    // );
    // editor.setValue(fallbackShader);

    let device;
    let context;
    let pipeline;
    let uniformBuffer;
    let bindGroup;
    let startTime = performance.now();
    let lastFrameTime = startTime;
    let frameCount = 0;
    let lastFpsUpdate = startTime;
    let mouseX = 0;
    let mouseY = 0;
    let mouseDown = false;
    // let isPanelOpen = true;
    // let isFullscreen = false;

    const $ = (id) => document.getElementById(id);
    const canvas = $("canvas");
    const errorMsg = $("error-message");
    const canvasContainer = $("canvas-container");
    const editorContainer = $("editor-container");
    const camera = {
      pos: [0, 0, -4],
      yaw: 0,
      pitch: 0,
      front: [0, 0, 1],
      right: [1, 0, 0],
      up: [0, 1, 0],
      speed: 5.0,
    };

    const keys = {};

    const scene = {
      spheres: [
        { pos: [1.5, 0.0, 0.0], r: 0.5, color: [1.0, 0.3, 0.3] }
      ],
      boxes: [
        { pos: [0.0, 0.0, 0.0], size: [0.3, 0.4, 0.3], color: [0.3, 1.0, 0.3] }
      ],
    };

    const uniforms = {
      resolution: { label: "resolution", initial: "0 × 0", update: (w, h) => `${w} × ${h}` },
      time: { label: "time", initial: "0.00s", update: (t) => `${t.toFixed(2)}s` },
    };

    // $("uniforms-table").innerHTML = Object.entries(uniforms)
    //   .map(
    //     ([key, u]) =>
    //       `<tr class="border-b" style="border-color:#3c3836"><td class="py-1.5 font-semibold" style="color:#fe8019">${u.label}</td><td class="py-1.5 text-right font-mono" id="u-${key}">${u.initial}</td></tr>`,
    //   )
    //   .join("");

    function createControl(label, value, type, callback, step = 0.01, min = -5, max = 5) {
      const div = document.createElement("div");
      div.className = "mb-2";
      div.innerHTML = `
          <div class="flex justify-between text-xs mb-1" style="color:#a89984">${label}</div>
          <div class="flex gap-2">
            <input type="${type}" value="${value}" step="${step}" min="${min}" max="${max}" class="w-full bg-[#3c3836] text-[#ebdbb2] rounded px-1 text-xs border-none outline-none focus:ring-1 ring-[#fe8019]">
          </div>
        `;
      const input = div.querySelector("input");
      input.oninput = (e) => callback(type === "number" || type === "range" ? parseFloat(e.target.value) : e.target.value);
      return div;
    }

    function createVec3Control(label, vec, callback, min = -5, max = 5) {
      const div = document.createElement("div");
      div.className = "mb-3";
      div.innerHTML = `<div class="text-xs font-bold mb-1" style="color:#fabd2f">${label}</div>`;

      const axisColors = ["#ff3333", "#33ff33", "#3333ff"];
      ["x", "y", "z"].forEach((axis, i) => {
        const row = document.createElement("div");
        row.className = "flex items-center gap-2 mb-1";
        row.innerHTML = `
                <span class="text-xs w-8 uppercase font-bold" style="color:${axisColors[i]}">${axis}</span>
                <input type="range" min="${min}" max="${max}" step="0.01" value="${vec[i]}" class="flex-1 h-1 bg-[#1d2021] rounded appearance-none cursor-pointer">
                <span class="text-xs w-8 text-right font-mono" style="color:#ebdbb2">${vec[i].toFixed(2)}</span>
            `;
        const input = row.querySelector("input");
        const valDisplay = row.querySelector("span:last-child");
        input.oninput = (e) => {
          const val = parseFloat(e.target.value);
          vec[i] = val;
          valDisplay.textContent = val.toFixed(2);
          callback();
        };
        div.appendChild(row);
      });
      return div;
    }

    function createColorControl(label, color, callback) {
      const div = document.createElement("div");
      div.className = "mb-3 flex items-center justify-between";

      // Convert normalized float color to hex
      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16).padStart(2, "0");
        return hex;
      };
      const hexColor = `#${toHex(color[0])}${toHex(color[1])}${toHex(color[2])}`;

      div.innerHTML = `
            <div class="text-xs font-bold" style="color:#fabd2f">${label}</div>
            <input type="color" value="${hexColor}" class="bg-transparent border-none w-8 h-8 cursor-pointer">
          `;

      const input = div.querySelector("input");
      input.oninput = (e) => {
        const hex = e.target.value;
        color[0] = parseInt(hex.substr(1, 2), 16) / 255;
        color[1] = parseInt(hex.substr(3, 2), 16) / 255;
        color[2] = parseInt(hex.substr(5, 2), 16) / 255;
        callback();
      };
      return div;
    }

    function initSceneEditor() {
      const container = $("panel-content");
      container.innerHTML = ""; // Clear

      const addBtnDiv = document.createElement("div");
      addBtnDiv.className = "flex gap-2 mb-4";
      addBtnDiv.innerHTML = `
            <button id="add-sphere" class="flex-1 bg-[#d65d0e] text-[#ebdbb2] py-1 rounded text-xs hover:opacity-80">Add Sphere</button>
            <button id="add-box" class="flex-1 bg-[#689d6a] text-[#ebdbb2] py-1 rounded text-xs hover:opacity-80">Add Box</button>
          `;
      container.appendChild(addBtnDiv);

      addBtnDiv.querySelector("#add-sphere").onclick = () => {
        if (scene.spheres.length < 4) {
          scene.spheres.push({ pos: [0, 0, 0], r: 0.5, color: [1.0, 0.5, 0.5] });
          initSceneEditor();
        }
      };
      addBtnDiv.querySelector("#add-box").onclick = () => {
        if (scene.boxes.length < 4) {
          scene.boxes.push({ pos: [0, 0, 0], size: [0.5, 0.5, 0.5], color: [0.5, 1.0, 0.5] });
          initSceneEditor();
        }
      };

      // Spheres
      scene.spheres.forEach((s, i) => {
        const wrapper = document.createElement("div");
        wrapper.className = "mb-4 p-2 bg-[#3c3836] rounded";
        wrapper.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-[#fe8019]">Sphere ${i + 1}</span>
                    <button class="text-[#cc241d] hover:text-white text-xs">✕</button>
                </div>
              `;
        wrapper.querySelector("button").onclick = () => {
          scene.spheres.splice(i, 1);
          initSceneEditor();
        };

        wrapper.appendChild(createVec3Control("Pos", s.pos, () => { }));

        const rDiv = document.createElement("div");
        rDiv.className = "mb-2 flex items-center gap-2";
        rDiv.innerHTML = `<span class="text-xs w-8 text-[#a89984]">Rad</span><input type="range" min="0.1" max="2.0" step="0.01" value="${s.r}" class="flex-1 h-1 bg-[#1d2021] rounded appearance-none cursor-pointer">`;
        rDiv.querySelector("input").oninput = (e) => s.r = parseFloat(e.target.value);
        wrapper.appendChild(rDiv);

        wrapper.appendChild(createColorControl("Color", s.color, () => { }));
        container.appendChild(wrapper);
      });

      // Boxes
      scene.boxes.forEach((b, i) => {
        const wrapper = document.createElement("div");
        wrapper.className = "mb-4 p-2 bg-[#3c3836] rounded";
        wrapper.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-[#b8bb26]">Box ${i + 1}</span>
                    <button class="text-[#cc241d] hover:text-white text-xs">✕</button>
                </div>
              `;
        wrapper.querySelector("button").onclick = () => {
          scene.boxes.splice(i, 1);
          initSceneEditor();
        };

        wrapper.appendChild(createVec3Control("Pos", b.pos, () => { }));
        wrapper.appendChild(createVec3Control("Size", b.size, () => { }, 0.1, 2.0));
        wrapper.appendChild(createColorControl("Color", b.color, () => { }));
        container.appendChild(wrapper);
      });
    }

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const dpr = devicePixelRatio || 1;
      const prevX = mouseX / dpr;
      const prevY = mouseY / dpr;
      const currX = e.clientX - rect.left;
      const currY = e.clientY - rect.top;

      [mouseX, mouseY] = [currX * dpr, currY * dpr];

      if (mouseDown) {
        const dx = (currX - prevX);
        const dy = (currY - prevY);

        if (e.buttons === 1) { // Left Click: Look
          // Lower sensitivity
          cameraState.yawVel -= dx * 0.0005; // Was 0.002
          cameraState.pitchVel -= dy * 0.0005; // Was 0.002
        } else if (e.buttons === 2 || e.buttons === 4) { // Right/Middle Click: Pan
          const r = camera.right;
          const u = camera.up;
          const panSpeed = 0.002; // Reduced from 0.005

          // Momentum for pan
          cameraState.velocity[0] -= (r[0] * dx - u[0] * dy) * panSpeed * 50;
          cameraState.velocity[1] -= (r[1] * dx - u[1] * dy) * panSpeed * 50;
          cameraState.velocity[2] -= (r[2] * dx - u[2] * dy) * panSpeed * 50;
        }
      }
    });

    canvas.addEventListener("mousedown", (e) => {
      mouseDown = true;
      // Prevent context menu on right click
      if (e.button === 2) e.preventDefault();
    });
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());
    canvas.addEventListener("mouseup", () => (mouseDown = false));
    canvas.addEventListener("mouseleave", () => (mouseDown = false));
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomSpeed = 0.005;
      const f = camera.front;
      const delta = e.deltaY * zoomSpeed;

      camera.pos[0] -= f[0] * delta;
      camera.pos[1] -= f[1] * delta;
      camera.pos[2] -= f[2] * delta;
    }, { passive: false });

    window.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

    // $("panel-toggle").onclick = () => {
    //   isPanelOpen = !isPanelOpen;
    //   $("uniforms-panel").style.width = isPanelOpen ? "250px" : "24px";
    //   $("panel-content").style.display = isPanelOpen ? "flex" : "none";
    //   $("toggle-arrow").textContent = isPanelOpen ? "▶" : "◀";
    // };

    const vertexShader = `@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  var pos = array<vec2<f32>, 3>(vec2<f32>(-1.0, -1.0), vec2<f32>(3.0, -1.0), vec2<f32>(-1.0, 3.0));
  return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}`;

    const uniformsStruct = `
struct Sphere {
    pos: vec3<f32>,
    r: f32,
    color: vec3<f32>,
    _pad: f32,
}

struct Box {
    pos: vec3<f32>,
    _pad1: f32,
    size: vec3<f32>,
    _pad2: f32,
    color: vec3<f32>,
    _pad3: f32,
}

struct Scene {
    spheres: array<Sphere, 4>,
    boxes: array<Box, 4>,
    num_spheres: u32,
    num_boxes: u32,
    _pad1: u32,
    _pad2: u32,
}

struct Uniforms {
    resolution: vec2<f32>,
    time: f32,
    deltaTime: f32,
    mouse: vec4<f32>,
    frame: u32,
    _pad_u1: u32,
    _pad_u2: u32,
    _pad_u3: u32,
    camera_pos: vec3<f32>,
    _pad_cam1: f32,
    camera_front: vec3<f32>,
    _pad_cam2: f32,
    scene: Scene,
}
@group(0) @binding(0) var<uniform> uniforms: Uniforms;`;

    async function initWebGPU() {
      if (!navigator.gpu)
        return ((errorMsg.textContent = "WebGPU not supported"), false);
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) return ((errorMsg.textContent = "No GPU adapter"), false);
      device = await adapter.requestDevice();
      context = canvas.getContext("webgpu");
      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({ device, format });
      uniformBuffer = device.createBuffer({
        size: 416, // 80 (base) + 336 (scene)
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });
      await compileShader(fallbackShader);
      return true;
    }

    async function compileShader(fragmentCode) {
      const start = performance.now();
      try {
        errorMsg.classList.add("hidden");
        const code = vertexShader + "\n" + uniformsStruct + "\n" + fragmentCode; // prettier-ignore
        const shaderModule = device.createShaderModule({ code });
        const info = await shaderModule.getCompilationInfo();
        const lineOffset = (vertexShader + "\n" + uniformsStruct).split("\n").length; // prettier-ignore
        const errors = info.messages
          .filter((m) => m.type === "error")
          .map((m) => {
            const fragmentLine = m.lineNum - lineOffset;
            return fragmentLine > 0
              ? `Line ${fragmentLine}: ${m.message}`
              : `Line ${m.lineNum}: ${m.message}`;
          })
          .join("\n");
        if (errors)
          return (
            (errorMsg.textContent = "Shader error:\n" + errors),
            errorMsg.classList.remove("hidden")
          );

        const format = navigator.gpu.getPreferredCanvasFormat();
        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.FRAGMENT,
              buffer: { type: "uniform" },
            },
          ],
        });
        pipeline = device.createRenderPipeline({
          layout: device.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout],
          }),
          vertex: { module: shaderModule, entryPoint: "vs_main" },
          fragment: {
            module: shaderModule,
            entryPoint: "fs_main",
            targets: [{ format }],
          },
          primitive: { topology: "triangle-list" },
        });
        bindGroup = device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
        });
        // $("compile-time").textContent = `${(performance.now() - start).toFixed(2)}ms`; // prettier-ignore
      } catch (e) {
        errorMsg.textContent = "Compile error: " + e.message;
        errorMsg.classList.remove("hidden");
      }
    }

    // Camera state with momentum
    const cameraState = {
      velocity: [0, 0, 0],
      yawVel: 0,
      pitchVel: 0,
      friction: 0.8, // Increased friction (was 0.9)
      acceleration: 0.5
    };

    function updateCamera(dt) {
      const s = camera.speed * dt;
      const acc = cameraState.acceleration;

      // Mouse look smoothing
      camera.yaw += cameraState.yawVel;
      camera.pitch += cameraState.pitchVel;

      // Damping
      cameraState.yawVel *= 0.5; // Faster stop (was 0.8)
      cameraState.pitchVel *= 0.5; // Faster stop (was 0.8)

      camera.pitch = Math.max(-1.5, Math.min(1.5, camera.pitch));

      camera.front = [
        Math.sin(camera.yaw) * Math.cos(camera.pitch),
        Math.sin(camera.pitch),
        Math.cos(camera.yaw) * Math.cos(camera.pitch)
      ];

      // Re-calculate right/up vectors for movement
      const f = camera.front;
      const r = [Math.cos(camera.yaw), 0, -Math.sin(camera.yaw)]; // Simple right vector on XZ plane
      const u = [0, 1, 0];

      // Store right/up for pan
      camera.right = r;
      camera.up = u;

      // Input vector
      let inputDir = [0, 0, 0];

      // AZERTY: ZQSD
      // User requested Q/D swap: Q=Right, D=Left (or just fixed if it was wrong)
      // Standard AZERTY: Q is Left, D is Right.
      // User said "inverted Q and D", so I will swap my previous logic.
      // Previous: Q=Left, D=Right.
      // New: Q=Right, D=Left.

      if (keys["z"]) { inputDir[0] += f[0]; inputDir[1] += f[1]; inputDir[2] += f[2]; }
      if (keys["s"]) { inputDir[0] -= f[0]; inputDir[1] -= f[1]; inputDir[2] -= f[2]; }

      // Swapped Q and D logic as requested
      if (keys["q"]) { inputDir[0] += r[0]; inputDir[1] += r[1]; inputDir[2] += r[2]; } // Q -> Right
      if (keys["d"]) { inputDir[0] -= r[0]; inputDir[1] -= r[1]; inputDir[2] -= r[2]; } // D -> Left

      if (keys["a"]) { inputDir[1] += 1; } // Up
      if (keys["e"]) { inputDir[1] -= 1; } // Down

      // Normalize input to avoid faster diagonal movement
      const len = Math.sqrt(inputDir[0] ** 2 + inputDir[1] ** 2 + inputDir[2] ** 2);
      if (len > 0) {
        inputDir[0] /= len;
        inputDir[1] /= len;
        inputDir[2] /= len;
      }

      // Apply acceleration
      if (len > 0) {
        cameraState.velocity[0] += inputDir[0] * acc * dt * 100;
        cameraState.velocity[1] += inputDir[1] * acc * dt * 100;
        cameraState.velocity[2] += inputDir[2] * acc * dt * 100;
      }

      // Apply velocity
      camera.pos[0] += cameraState.velocity[0] * dt;
      camera.pos[1] += cameraState.velocity[1] * dt;
      camera.pos[2] += cameraState.velocity[2] * dt;

      // Friction
      cameraState.velocity[0] *= cameraState.friction;
      cameraState.velocity[1] *= cameraState.friction;
      cameraState.velocity[2] *= cameraState.friction;
    }

    function render() {
      if (!pipeline) return;
      const currentTime = performance.now();
      const deltaTime = (currentTime - lastFrameTime) / 1000;
      const elapsedTime = (currentTime - startTime) / 1000;

      updateCamera(deltaTime);

      // Serialize Uniforms
      // Base: resolution(2), time(1), dt(1), mouse(4), frame(1), pad(3) -> 12 floats + 3 pads? 
      // Layout:
      // 0-8: res (2f)
      // 8-12: time (1f)
      // 12-16: dt (1f)
      // 16-32: mouse (4f)
      // 32-36: frame (1u)
      // 36-48: pad (3u)
      // 48-60: cam_pos (3f)
      // 60-64: pad (1f)
      // 64-76: cam_front (3f)
      // 76-80: pad (1f)
      // 80: Scene

      const baseData = new Float32Array(20); // 80 bytes / 4 = 20 floats
      baseData.set([canvas.width, canvas.height], 0);
      baseData.set([elapsedTime], 2);
      baseData.set([deltaTime], 3);
      baseData.set([mouseX, mouseY, mouseDown ? 1 : 0, 0], 4);
      // Frame is u32, handle separately or cast
      baseData.set([...camera.pos, 0], 12);
      baseData.set([...camera.front, 0], 16);

      device.queue.writeBuffer(uniformBuffer, 0, baseData);
      device.queue.writeBuffer(uniformBuffer, 32, new Uint32Array([frameCount])); // Write frame at offset 32

      // Serialize Scene
      // Spheres: 4 * 8 floats = 32 floats
      // Boxes: 4 * 12 floats = 48 floats
      // Counts: 2 u32

      const sceneOffset = 80;
      const sphereSize = 32; // bytes
      const boxSize = 48; // bytes

      // Write Spheres
      const sphereData = new Float32Array(4 * 8);
      scene.spheres.forEach((s, i) => {
        if (i >= 4) return;
        sphereData.set([...s.pos, s.r, ...s.color, 0], i * 8);
      });
      device.queue.writeBuffer(uniformBuffer, sceneOffset, sphereData);

      // Write Boxes
      const boxData = new Float32Array(4 * 12);
      scene.boxes.forEach((b, i) => {
        if (i >= 4) return;
        boxData.set([...b.pos, 0, ...b.size, 0, ...b.color, 0], i * 12);
      });
      device.queue.writeBuffer(uniformBuffer, sceneOffset + 128, boxData);

      // Write Counts
      device.queue.writeBuffer(uniformBuffer, sceneOffset + 128 + 192, new Uint32Array([scene.spheres.length, scene.boxes.length]));

      // UI Updates
      $("fps").textContent = Math.round(1 / deltaTime) + " FPS";

      lastFrameTime = currentTime;

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass({
        colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            storeOp: "store",
          },
        ],
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
      device.queue.submit([encoder.finish()]);

      frameCount++;
      requestAnimationFrame(render);
    }

    function resizeCanvas() {
      const container = $("canvas-container");
      const dpr = devicePixelRatio || 1;
      canvas.width = container.clientWidth * dpr;
      canvas.height = container.clientHeight * dpr;
      canvas.style.width = container.clientWidth + "px";
      canvas.style.height = container.clientHeight + "px";
    }

    // Removed compileBtn.onclick
    // Removed fullscreen functions
    // Removed shaderSelector listeners

    // Load shaders from files
    async function loadShaders() {
      try {
        const response = await fetch("./shaders/raymarch_basic.wgsl");
        if (response.ok) {
          fallbackShader = await response.text();
          console.log("Loaded raymarch_basic.wgsl");
        }
      } catch (err) {
        console.error("Failed to load shader:", err);
      }
    }




    // Main initialization
    const main = async () => {
      await loadShaders();
      resizeCanvas();
      if (await initWebGPU()) {
        initSceneEditor();
        render();
      }
    };
    main();
  </script>
</body>

</html>